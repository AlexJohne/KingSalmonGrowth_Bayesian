---
title: "Fit intake and growth data"
author: "Shane A. Richards"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    highlight: tango
    theme: cerulean
    toc: yes
    toc_float: no
  word_document:
    toc: yes
  pdf_document:
    toc: yes
---

----

# Summary

In this document we build on the intake model to incorporate costs to resolve fish growth. Fish intake depends on a fish's weight and its weight relative to others in the same tank.  

----

# Model

## Intake and energetic costs

Here, we assume energy density is constant, which means rates of change in fish weight can be expressed in terms of weight-dependent gains and losses. Let $w_{j,t}$ denote the weight of fish $j$ on day $t$, and $r_{j,t}$ be its relative weight compared with the average weight of others in the tank. The expected intake rate of this individual on day $t$ is 

$$
I_{j,t} = a_1 e^{c_1 r_{j,t}} \bigg (\frac{w_{j,t}}{\bar{w}} \bigg )^{b_1} e^{\delta_j}.
$$

Variation in intake is assumed to be consistent with a gamma distribution, where the coefficient of variation is related to the mean weight according to
$$
\text{cv}_{j,t} = a_2 e^{b_2(w_{j,t} - \bar{w})/\bar{w}}.
$$    
Note: $\alpha = \text{cv}_{j,t}^{-2}$ and $\beta = \alpha/I_{j,t}$.

The daily gain in weight of this fish is $\varepsilon I_{j,t}$ and the daily cost in weight is 

$$
M_{j,t} = a_3 \bigg (\frac{w_{j,t}}{\bar{w}} \bigg )^{b_3} e^{\eta_j}.
$$
Here, $\delta_j$ and $\eta_j$ describe individual-specific deviations from the population median intake and cost, respectively,  and we assume come from a bivariate normal distribution with correlation $\rho$.

Thus, the expected daily change in weight is

$$
w_{j,t+1} = w_{j,t} + \varepsilon I_{j,t}(w_{j,t},r_{j,t}) - M_{j,t}(w_{j,t}).
$$

Weights are provided at four times: $t = \{T_0, T_1, T_2, T_3 \}$. To implement the growth model requires daily estimates of relative size, which can be estimated using linear regression

$$
r_{j,t} = r_{j,T_i} + \frac{t - T_i}{T_{i+1} - T_i} \left ( r_{j,T_{i+1}} - r_{j,T_i} \right )
$$

These relative weights can be calculated prior to fitting and supplied to the stan fitting function. When calculating relative weights we will use the mean weight provided in the file `100S_feed_provided.csv`.

Note that when applying this bio-energetic model it is common to assume $b_1 = 2/3$ and $b_3 = 1$ (or even less; $b_3 = 0.8$) (Essington et al., 2001). An objective of this analysis is to see if these assumptions are consistent with our intake and growth data.

## Correlation between relative intake and relative cost

The stan model `IntakeFit_Experimental_2.stan` estimates the correlation between the individual-level random effects associated with intake and costs, but fitting this correlation is a little complicated. First, for each individual fish, uncorrelated standard normals are generated for intake and costs, respectively. These paired random effects are then correlated by a linear transformation. The stan code `diag_pre_multiply(sigma_u, L_u)` fits a lower diagonal matrix:
$$
L = \begin{pmatrix} a & 0\\ b & c \end{pmatrix}
$$
where $a^2$ is the variance of the residuals associated with intake. The covariance between the intake and cost residuals is
$$
\text{Cov}(aZ_\text{I},bZ_\text{I}+cZ_\text{C}) = ab
$$
where $Z_\text{I}$ and $Z_\text{C}$ are the uncorrelated standard normals for intake and costs, respectively. The variance of the residuals associated with costs is $(b^2 + c^2)$. The correlation between the two random effects $X_\text{I} = aZ_\text{I}$ and $X_\text{C} = bZ_\text{I} + cZ_\text{C}$ is
$$
\rho = \frac{\text{Cov}(X_\text{I},X_\text{C})} {\sqrt{ \text{Var}(X_\text{I}) \text{Var}(X_\text{C}) }} = \frac{ab}{\sqrt{a^2(b^2+c^2)}}
$$
This last equation is implemented in `generated quantities` to estimate $\rho$.

```{r message=FALSE, warning=FALSE}
library(tidyverse) # data frame functionality
library(cowplot)   # create multi-plots
library(rstan)     # create a stan model
library(bayesplot) # plot Bayesian output

rm(list = ls()) # clear memory

# global parameter
w_std <- 600.0 # standard weight (a1 = intake, cov = a2)

# read in data and wrangle
# individual feed consumption data
df_indiv <- read_csv("100S_fish_growth.csv")  %>%
  dplyr::select(c(2,3,4,5,7)) # ID, tank, days, weight, intake

# set up individual data frame
df_indiv <- df_indiv %>% filter(!is.na(intake)) %>% filter(intake > 0) %>%
	na.omit()

df_indiv$ID   <- factor(df_indiv$ID)
df_indiv$tank <- factor(df_indiv$tank)
df_indiv$days[which(df_indiv$days == 276)] <- 274 # set all final times to 274 (approx.)
df_indiv$j    <- as.integer(df_indiv$ID)   # j = fish
df_indiv$l    <- as.integer(df_indiv$tank) # l = tank

# calculate mean weights per sample
df_wbar <- df_indiv %>% 
  group_by(tank, days) %>%
	summarise(.groups = "drop", n = n(), w_bar = mean(w))

# add appropriate mean weights from group data
df_indiv <- df_indiv %>%
  left_join(df_wbar, by = c("days", "tank")) %>%
  mutate(r = (w - w_bar) / w_bar)

glimpse(df_indiv)
```

There are `r nrow(df_indiv)` observations spanning `r length(levels(df_indiv$ID))` individuals.

```{r}
p1 <- ggplot(df_indiv) +
  geom_point(aes(x = w, y = intake, color = r, shape = factor(days))) +
  facet_wrap( ~ tank, ncol = 1) +
  labs(x = "Weight (g)", y = "Intake (g/ind.)", color = "Relative\nweight") +
  scale_colour_gradient2(
    low = "red",
    mid = "grey70",
    high = "blue",
    midpoint = 0
  ) +
	facet_grid(factor(days) ~ tank) +
  theme_bw() +
	theme(legend.position = "none")

p1
```


```{r}
p2 <- ggplot(df_indiv) +
  geom_point(aes(x = days, y = w, color = tank)) +
  geom_line(aes(x = days, y = w, color = tank, group = ID), alpha = 0.2) +
  facet_wrap( ~ tank, ncol = 1) +
  labs(x = "Day", y = "Weight (g)") +
  theme_bw() +
	theme(legend.position = "none")

p3 <- ggplot(df_indiv) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_point(aes(x = days, y = r, color = tank)) +
  geom_line(aes(x = days, y = r, color = tank, group = ID), alpha = 0.2) +
  facet_wrap( ~ tank, ncol = 1) +
  labs(x = "Day", y = "Relative weight difference") +
  theme_bw() +
	theme(legend.position = "none")

plot_grid(p2, p3, ncol = 2) # plot intake and growth data
```

```{r}
sample_times <- (df_indiv %>%
  dplyr::select(days) %>%
  unique() %>%
  arrange(days))$days # days when sampling occurs

S <- length(sample_times) # number of sample times
df_samples <- tibble(s = 1:S, days = sample_times)

df_indiv <- left_join(df_indiv, df_samples, by = "days")

days_min <- min(df_indiv$days) # minimum sample day
days_max <- max(df_indiv$days) # maximum sample day
D <- 1 + days_max - days_min   # days between first and last samples
```

```{r}
# collect individual traits
df_ind_stats <- df_indiv %>%
  group_by(j, l) %>%
  summarise(.groups = "drop",
    Obs = n(),
    d_min = min(days) - days_min + 1,
    d_max = max(days) - days_min + 1)

J <- max(df_indiv$j) # number of fish

df_indiv$d <- 1 + df_indiv$days - days_min

m_d <- matrix(data = 0, nrow = J, ncol = S) # sample
m_w <- matrix(data = 0, nrow = J, ncol = S) # weight

for (jj in 1:J) {
  ws <- (df_indiv %>% filter(j == jj))$w
  ds <- (df_indiv %>% filter(j == jj))$d
  num_ws <- length(ws) 
  if (!is.null(num_ws)) {
  	for (kk in 1:num_ws) {
      m_d[jj,kk] <- ds[kk]
      m_w[jj,kk] <- ws[kk]
  	}
  }
}  

# create the linearly interpolated relative weights
m_r <- matrix(data = NA, nrow = J, ncol = D)

for (i in 1:nrow(df_indiv)) {
  m_r[df_indiv$j[i], df_indiv$d[i]] <- df_indiv$r[i]	
}

for (j in 1:J) {
  ds <- which(!is.na(m_r[j,])) # times when r is provided
  num_ds <- length(ds) 
  if (!is.null(num_ds) & num_ds > 1) {
  	for (i in 1:(num_ds - 1)) {
  	  dd <- ds[i+1] - ds[i]
  	  for (d in ds[i]:ds[i+1]) {
        m_r[j,d] <- m_r[j,ds[i]] + (d - ds[i])*(m_r[j,ds[i+1]] - m_r[j,ds[i]]) / dd
  	  }
  	}
  }
  m_r[j,which(is.na(m_r[j, ]))] <- 0.0
}
```

```{r}
# prepare the data (stan wants a list of data not a data frame)
df_fit <- df_indiv %>%
  mutate(
    sample = factor(paste(s, "_", l, sep = "")), # sample, tank pairing
    k      = as.integer(sample))

I <- nrow(df_fit)            # number of observations
J <- max(df_fit$j)           # number of fish
L <- max(df_fit$l)           # number of tanks
K <- max(df_fit$k)           # number of tank samples
S <- max(df_fit$s)           # number of sample times
D <- max(df_fit$d)           # number of days 

stan_dat <- list(
  I      = I,                # number of intake observations
  J      = J,                # number of fish
  K      = K,                # number of samples (time x tank)
  D      = D,                # number of days
  S      = S,                # number of sample times
  w_std  = w_std,            # standardised fish weight (should be a typical weight)  
  j      = df_fit$j,         # fish 
  k      = df_fit$k,         # sample (time x tank)
  w      = df_fit$w,         # fish weight
  w_rel  = df_fit$r,         # relative weight
  Intake = df_fit$intake,    # intake
  m_r    = m_r,              # relative fish weight
  m_d    = m_d,              # sample time (days since first)
  v_w    = df_ind_stats$Obs, # number of weights per individual
  m_w    = m_w               # fish weights
)   

str(stan_dat) # data to fit to stan model
```

```{r}
# fit the model!
fit_n <- stan(file = 'IntakeFit_Experimental_2.stan', data = stan_dat,
  iter = 400, warmup = 150, chains = 2, refresh = 10, seed = 42)
```

```{r}
# check out some predicted model parameters
model_par <- c("a1", "b1", "c1", "a2", "b2", "rho",
	"a3", "b3", "a4", "eta", "sigma_k")

# check for chain convergence
rstan::traceplot(object = fit_n, pars = model_par, inc_warmup = TRUE, ncol = 4)
```

```{r}
# display summary of key model parameters
summary(fit_n, pars = model_par, probs = c(0.025, 0.50, 0.975))[[1]]
```

# Predictions

```{r}
# extract posterior model parameters 
# intake parameters
a1   <- rstan::extract(fit_n, pars = "a1")[[1]]
b1   <- rstan::extract(fit_n, pars = "b1")[[1]]
c1   <- rstan::extract(fit_n, pars = "c1")[[1]]
a2   <- rstan::extract(fit_n, pars = "a2")[[1]]
b2   <- rstan::extract(fit_n, pars = "b2")[[1]]
# growth parameters
a3   <- rstan::extract(fit_n, pars = "a3")[[1]]
b3   <- rstan::extract(fit_n, pars = "b3")[[1]]
eta  <- rstan::extract(fit_n, pars = "eta")[[1]]
# individual variation
RE_I_j <- rstan::extract(fit_n, pars = "u")[[1]][ ,1,]
RE_C_j <- rstan::extract(fit_n, pars = "u")[[1]][ ,2,]
rho    <- rstan::extract(fit_n, pars = "rho")[[1]]

Reps <- length(a1) # number of posterior samples per parameter
```

```{r}
# set weights for predictions
df_predict <- tibble(
  w = seq(from = min(df_fit$w), to = max(df_fit$w), length.out = 100)
) %>% # add intake and cv columns (include uncertainty bounds)
  mutate(
  	I_025  = 0.0, I_500  = 0.0, I_975  = 0.0, # intake
  	cv_025 = 0.0, cv_500 = 0.0, cv_975 = 0.0, # coefficient of variation (intake)
  	G_025  = 0.0, G_500  = 0.0, G_975  = 0.0, # growth (daily)
  	M_025  = 0.0, M_500  = 0.0, M_975  = 0.0, # cost (daily)
  	NG_025 = 0.0, NG_500 = 0.0, NG_975 = 0.0  # net growth = grwowth - cost 
  )

# make predictions of intake and cv and calculate uncertainty (for typical fish; r = 0)
for (i in 1:nrow(df_predict)) {
	# intake 
  df_predict$I_025[i] <- quantile(
    a1*(df_predict$w[i]/w_std)^b1, probs = 0.025)
  df_predict$I_500[i] <- quantile(
    a1*(df_predict$w[i]/w_std)^b1, probs = 0.500)
  df_predict$I_975[i] <- quantile(
    a1*(df_predict$w[i]/w_std)^b1, probs = 0.975)
  
  # intake cv 
  df_predict$cv_025[i] <- quantile(
    a2*exp(b2*(df_predict$w[i]-w_std)/w_std), probs = 0.025)
  df_predict$cv_500[i] <- quantile(
    a2*exp(b2*(df_predict$w[i]-w_std)/w_std), probs = 0.500)
  df_predict$cv_975[i] <- quantile(
    a2*exp(b2*(df_predict$w[i]-w_std)/w_std), probs = 0.975)
  
  # growth gain 
  df_predict$G_025[i] <- quantile(
    eta*a1*(df_predict$w[i]/w_std)^b1, probs = 0.025)
  df_predict$G_500[i] <- quantile(
    eta*a1*(df_predict$w[i]/w_std)^b1, probs = 0.500)
  df_predict$G_975[i] <- quantile(
    eta*a1*(df_predict$w[i]/w_std)^b1, probs = 0.975)

  # growth cost 
  df_predict$M_025[i] <- quantile(
    a3*(df_predict$w[i]/w_std)^b3, probs = 0.025)
  df_predict$M_500[i] <- quantile(
    a3*(df_predict$w[i]/w_std)^b3, probs = 0.500)
  df_predict$M_975[i] <- quantile(
    a3*(df_predict$w[i]/w_std)^b3, probs = 0.975)
  
  # net daily gain
  df_predict$NG_025[i] <- quantile(
    eta*a1*(df_predict$w[i]/w_std)^b1 - a3*(df_predict$w[i]/w_std)^b3, probs = 0.025)
  df_predict$NG_500[i] <- quantile(
    eta*a1*(df_predict$w[i]/w_std)^b1 - a3*(df_predict$w[i]/w_std)^b3, probs = 0.500)
  df_predict$NG_975[i] <- quantile(
    eta*a1*(df_predict$w[i]/w_std)^b1 - a3*(df_predict$w[i]/w_std)^b3, probs = 0.975)
}

# calculate intake uncertainty for some weight bins to test cv predictions
df_summary <- df_indiv %>% mutate(ln_w = log(w))
df_summary$ln_w_bin <- cut(df_summary$ln_w, breaks = 8) # add bins

df_summary <- df_summary %>%
  group_by(ln_w_bin, tank) %>%
	summarise(.groups = "drop",
		n           = n(),           # number of fish
		median_w    = median(w),     # mean weight in the weight bin
		intake_mean = mean(intake),  # mean intakein the bin
		cov = sd(intake)/intake_mean # cv of intake for the bin
	) %>%
	filter(n >= 20)

# generate plots from above predictions
p_Intake <- ggplot() +
  geom_point(data = df_fit,
    aes(x = w, y = intake, color = r)) +
  geom_ribbon(data = df_predict,
    aes(x = w, ymin = I_025, ymax = I_975), fill = "salmon") +
  geom_line(data = df_predict,
    aes(x = w, y = I_500), color = "darkred") +
  labs(x = "Weight (g)", y = "Intake (g/ind./day)") +
	scale_colour_gradient2(
    low = "red",
    mid = "grey85",
    high = "green",
    midpoint = 0
  ) +
  theme_bw()

p_IntakeCoV <- ggplot() +
  geom_ribbon(data = df_predict,
    aes(x = w, ymin = cv_025, ymax = cv_975), fill = "salmon") +
  geom_line(data = df_predict,
    aes(x = w, y = cv_500), color = "darkred") +
  geom_point(data = df_summary,
    aes(x = median_w, y = cov)) +
  labs(x = "Weight (g)", y = "Coefficient of variation") +
  theme_bw()

p_NetGrowth <- ggplot() +
  geom_hline(yintercept = 0.0, linetype = "dashed")  + 
  geom_ribbon(data = df_predict,
    aes(x = w, ymin = M_025, ymax = M_975), fill = "salmon") +
  geom_line(data = df_predict,
    aes(x = w, y = M_500), color = "darkred") +
  geom_ribbon(data = df_predict,
    aes(x = w, ymin = G_025, ymax = G_975), fill = "green") +
  geom_line(data = df_predict,
    aes(x = w, y = G_500), color = "forestgreen") +
  geom_ribbon(data = df_predict,
    aes(x = w, ymin = NG_025, ymax = NG_975), fill = "skyblue") +
  geom_line(data = df_predict,
    aes(x = w, y = NG_500), color = "blue") +
  labs(x = "Weight (g)", y = "Weight gains/losses (g/day)") +
  theme_bw()

# make daily growth predictions
v_w <- df_ind_stats$Obs               # number of observed weights per fish
wP  <- array(data = NA, dim = c(J,S)) # store all weight predictions
EwP <- array(data = NA, dim = c(J,D)) # expected weight predictions

for (jj in 1:J) { # for each fish
  w <- array(data = 0.0, dim = c(D, Reps)) # all posterior predictions for fish jj
  if (v_w[jj] > 1) { # more than 1 weight so growth to predict
    for (ss in 1:(v_w[jj] - 1)) { # for each growth interval
      # predict weight change for individual jj from sample time ss -> ss+1
      w[m_d[jj,ss], ] <- m_w[jj,ss] # reset predictions to observed weights
      for (dd in (m_d[jj,ss]):(m_d[jj,ss+1]-1)) { # update weight each day
        w[dd+1, ] <- w[dd, ] + 
          eta*a1*exp(c1*m_r[jj,dd] + RE_I_j[ ,jj])*((w[dd, ]/w_std)^b1) -
              a3*exp(                RE_C_j[ ,jj])*((w[dd, ]/w_std)^b3) 
      }
      EwP[jj, ]   <- apply(w, 1, mean) # calculate mean weight for each day
      wP[jj,ss+1] <- mean(w[dd+1, ])   # store mean of predicted weights for sample day
    }
  }
}

# calculate expected growth curves for each fish
df_Ew <- as.data.frame(t(EwP))
names(df_Ew) <- as.character(1:J)
df_Ew$t <- days_min:days_max
df_Ew <- pivot_longer(df_Ew, names_to = "j", values_to = "w",1:J)
df_Ew$j <- as.integer(df_Ew$j)
df_Ew <- na.omit(df_Ew)
df_Ew <- filter(df_Ew, w > 0) # remove values that were not 

# convert arrays of observations and predictions into data frames
df_wP <- as.data.frame(wP)
names(df_wP)  <- as.character(sample_times) # predictions
df_wP$j <- 1:J
df_wP   <- pivot_longer(df_wP, values_to = "p", names_to = "d", 1:4)
df_wP$d <- as.integer(df_wP$d)

df_mw <- as.data.frame(m_w)
names(df_mw)  <- as.character(sample_times) # observations
df_mw$j <- 1:J
df_mw   <- pivot_longer(df_mw, values_to = "w", names_to = "d", 1:4)
df_mw$d <- as.integer(df_mw$d)

df_mw <- df_mw %>% filter(w > 0) %>%
  left_join(df_wP, by = c("j", "d")) # add day info

# creat a data frame with observed and predicted weights for plotting
df_plot <- na.omit(df_mw) # remove observations without predictions
df_plot <- df_plot %>% 
	left_join(dplyr::select(df_fit, j, w, r), by = c("j","w"))

p_Weights <- ggplot() +
  geom_point(data = df_plot, aes(x = p, y = w)) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") + 
  labs(y = "Observed weight (g)", x = "Predicted weight (g)") + 
  theme_bw() +
  theme(
    legend.position="top",
  	panel.background = element_rect(fill = "white"),
    panel.grid = element_line(colour = "grey95") 
  )

df_predict <- tibble(
  r = seq(from = min(df_fit$r), to = max(df_fit$r), length.out = 100),
    I_rel_025 = 0.0, I_rel_500 = 0.0, I_rel_975 = 0.0)
    
for (i in 1:nrow(df_predict)) {
  df_predict$I_rel_025[i] <- quantile(
    exp(c1*df_predict$r[i]), probs = 0.025)
  df_predict$I_rel_500[i] <- quantile(
    exp(c1*df_predict$r[i]), probs = 0.500)
  df_predict$I_rel_975[i] <- quantile(
    exp(c1*df_predict$r[i]), probs = 0.975)
}

p_REs <- ggplot(df_predict) +
  geom_hline(yintercept = 1.0, linetype = "dashed")  + 
  geom_ribbon(aes(x = r, ymin = I_rel_025, ymax = I_rel_975), 
    fill = "salmon") + 
  geom_line(aes(x = r, y = I_rel_500)) + 
  xlim(-1,1) + 
  labs(x = "Relative weight", y = "Relative intake") +
  theme_bw()

p_RelWeights <- ggplot(df_fit) +
  geom_histogram(aes(x = r), fill = "salmon", color = "darkred") + 
  labs(x = "Relative weight", y = "Frequency") +
  xlim(-1,1) +
  theme_bw()

plot_grid(p_Intake, p_REs, p_NetGrowth, p_IntakeCoV, p_RelWeights, p_Weights, ncol = 3)
```

```{r}
# extract individual level random effects for intake and costs
df_ind_stats$RE_I  <- apply(RE_I_j, MARGIN = 2, FUN = mean)
df_ind_stats$RE_C  <- apply(RE_C_j, MARGIN = 2, FUN = mean)
df_ind_stats$r_ave <- apply(m_r, MARGIN = 1, FUN = mean, na.rm = TRUE)

p_IndRel <- ggplot(df_ind_stats) + 
  geom_hline(yintercept = 0, color = "white") +
  geom_vline(xintercept = 0, color = "white") +
  geom_point(aes(x = RE_I, y = RE_C, color = r_ave)) +
  labs(
    x = "Relative [intake]", 
    y = "Relative [cost]", 
    color = "Relative\n[weight]") +
  scale_colour_gradient2(
    low = "red",
    mid = "grey85",
    high = "blue",
    midpoint = 0
  ) +
  theme_bw() +
  theme(
    panel.background = element_rect(fill = "grey10"),
    panel.grid = element_line(colour = "grey35") 
  )

p_Cost <- ggplot(df_ind_stats) + 
  geom_hline(yintercept = 0, color = "white") +
  geom_vline(xintercept = 0, color = "white") +
  geom_point(aes(x = r_ave, y = RE_C, color = RE_I)) +
  labs(x = "Relative [weight]", y = "Relative [cost]", color = "Relative\n[intake]") +
  scale_colour_gradient2(
    low = "red",
    mid = "grey85",
    high = "blue",
    midpoint = 0
  ) +
  theme_bw() +
  theme(
    panel.background = element_rect(fill = "grey10"),
    panel.grid = element_line(colour = "grey35") 
  )

df_plot <- df_Ew %>%
  filter(j %in% sample(1:J, size = 50, replace = FALSE)) %>%
  left_join(df_ind_stats, by = "j")

df_rho <- tibble(rho = rho)

p_rho <- ggplot(df_rho) + 
  geom_histogram(aes(x = rho, y=..density..)) +
  labs(x = "Rho (inake,cost)") +
  theme_bw()

p_weight <- ggplot(df_plot) + 
  geom_line(aes(x = t, y = w, color = RE_C, group = j)) +
  scale_colour_gradient2(
    low = "red",
    mid = "grey85",
    high = "blue",
    midpoint = 0
  ) +
  labs(x = "Time (days)", y = "Weight (g)", color = "Relative\n[cost]") +
  theme_bw() +
  theme(
    panel.background = element_rect(fill = "grey10"),
    panel.grid = element_line(colour = "grey35") 
  )

plot_grid(p_IndRel, p_rho, p_Cost, p_weight)
```

# Supplementary Information

```{r eval = FALSE, echo=FALSE}
# individual variation
CM      <- rstan::extract(fit_n, pars = "CM")[[1]]
CM_E    <- apply(CM, c(2,3), mean)
a <- CM_E[1,1]
b <- CM_E[2,1]
c <- CM_E[2,2]

rho <- rep(0.0, Reps)

mean(apply(RE_I_j,1,var))
a^2
mean(apply(RE_C_j,1,var))
b^2+c^2
a*b

for (i in 1:Reps) {
  rho[i] <- cov(RE_I_j[i,],RE_C_j[i,]) / sqrt(a*a*(b*b+c*c))
}
mean(rho)
hist(rho)
```

```{r comment=''}
cat(readLines('IntakeFit_Experimental_2.stan'), sep = '\n')
```

